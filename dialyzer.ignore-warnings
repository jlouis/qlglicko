leexinc.hrl:49: The pattern <Rest, Line, {'token', T, Push}, Ts> can never match the type <_,_,'error' | 'skip_token',[{atom(),_} | {'float',_,float()} | {'integer',_,[any()] | integer()} | {'string',_,[any()]} | {'var',_,atom()}]>
leexinc.hrl:52: The pattern <Rest, Line, {'end_token', T}, Ts> can never match the type <_,_,'error' | 'skip_token',[{atom(),_} | {'float',_,float()} | {'integer',_,[any()] | integer()} | {'string',_,[any()]} | {'var',_,atom()}]>
leexinc.hrl:54: The pattern <Rest, Line, {'end_token', T, Push}, Ts> can never match the type <_,_,'error' | 'skip_token',[{atom(),_} | {'float',_,float()} | {'integer',_,[any()] | integer()} | {'string',_,[any()]} | {'var',_,atom()}]>
leexinc.hrl:59: The pattern <Rest, Line, {'skip_token', Push}, Ts> can never match the type <_,_,'error',[{atom(),_} | {'float',_,float()} | {'integer',_,[any()] | integer()} | {'string',_,[any()]} | {'var',_,atom()}]>
leexinc.hrl:62: The pattern <_Rest, Line, {'error', S}, _Ts> can never match the type <_,_,'error',[{atom(),_} | {'float',_,float()} | {'integer',_,[any()] | integer()} | {'string',_,[any()]} | {'var',_,atom()}]>
leexinc.hrl:118: The pattern <Rest, Line, {'token', T, Push}> can never match the type <_,_,'error' | 'skip_token'>
leexinc.hrl:121: The pattern <Rest, Line, {'end_token', T}> can never match the type <_,_,'error' | 'skip_token'>
leexinc.hrl:123: The pattern <Rest, Line, {'end_token', T, Push}> can never match the type <_,_,'error' | 'skip_token'>
leexinc.hrl:128: The pattern <Rest, Line, {'skip_token', Push}> can never match the type <_,_,'error'>
leexinc.hrl:131: The pattern <Rest, Line, {'error', S}> can never match the type <_,_,'error'>
leexinc.hrl:192: The pattern <Rest, Line, {'token', T, Push}, Ts> can never match the type <_,_,'error' | 'skip_token',_>
leexinc.hrl:195: The pattern <Rest, Line, {'end_token', T}, Ts> can never match the type <_,_,'error' | 'skip_token',_>
leexinc.hrl:197: The pattern <Rest, Line, {'end_token', T, Push}, Ts> can never match the type <_,_,'error' | 'skip_token',_>
leexinc.hrl:202: The pattern <Rest, Line, {'skip_token', Push}, Ts> can never match the type <_,_,'error',_>
leexinc.hrl:205: The pattern <Rest, Line, {'error', S}, _Ts> can never match the type <_,_,'error',_>
leexinc.hrl:243: The pattern <Rest, Line, {'token', _T, Push}, Error> can never match the type <_,_,'error' | 'skip_token',_>
leexinc.hrl:246: The pattern <Rest, Line, {'end_token', _T}, Error> can never match the type <_,_,'error' | 'skip_token',_>
leexinc.hrl:248: The pattern <Rest, Line, {'end_token', _T, Push}, Error> can never match the type <_,_,'error' | 'skip_token',_>
leexinc.hrl:253: The pattern <Rest, Line, {'skip_token', Push}, Error> can never match the type <_,_,'error',_>
leexinc.hrl:256: The pattern <Rest, Line, {'error', _S}, Error> can never match the type <_,_,'error',_>
leexinc.hrl:260: Function yyrev/2 will never be called
exprecs.erl:525: The pattern RevAs = [{'function', NewLast, _, _, _} | _] can never match the type []
exprecs.erl:565: Function version_accessors/2 will never be called
exprecs.erl:571: Function will never be called
exprecs.erl:573: Function flat_versions/1 will never be called
exprecs.erl:614: The call lists:concat([[[{_,_,_,_} | {_,_,_,_,_},...],...],...]) breaks the contract (Things) -> string() when is_subtype(Things,[Thing]), is_subtype(Thing,atom() | integer() | float() | string())
exprecs.erl:678: Function fname/4 will never be called
exprecs.erl:975: Function f_info_3/3 will never be called
exprecs.erl:979: Function will never be called
exprecs.erl:1110: Function f_info_1/4 will never be called
exprecs.erl:1113: Function recname/2 will never be called
exprecs.erl:1116: Function f_convert/3 will never be called
gen_leader.erl:913: The call sys:handle_debug(Debug::any(),{'gen_leader', 'print_event'},atom(),{'in',_}) breaks the contract (Debug,FormFunc,Extra,Event) -> [dbg_opt()] when is_subtype(Debug,[dbg_opt()]), is_subtype(FormFunc,dbg_fun()), is_subtype(Extra,term()), is_subtype(Event,system_event())
gen_leader.erl:1100: The call sys:handle_debug(Debug::any(),{'gen_leader', 'print_event'},atom(),Event::{'$leader_cast',_} | {'noreply',_} | {'ok',_} | {'out',_,_,_}) breaks the contract (Debug,FormFunc,Extra,Event) -> [dbg_opt()] when is_subtype(Debug,[dbg_opt()]), is_subtype(FormFunc,dbg_fun()), is_subtype(Extra,term()), is_subtype(Event,system_event())
gproc_dist.erl:23: Callback info about the gen_leader behaviour is not available
jobs_info.erl:26: Overloaded contract has overlapping domains; such contracts are currently unsupported and are simply ignored
jobs_sampler_cpu.erl:26: Callback info about the jobs_sampler behaviour is not available
jobs_sampler_mnesia.erl:19: Callback info about the jobs_sampler behaviour is not available
jobs_server.erl:236: The call jobs_server:expand_opts([{_,_,_},...]) breaks the contract ([option()]) -> [option()]
jobs_server.erl:1370: Matching of pattern <_TS, {'queue', _, _, _, _, _, _, _, _, 'infinity', _, _, _, _, _}> tagged with a record name violates the declared type of #queue{mod::atom(),type::'fifo' | 'lifo' | #action{a::'approve' | 'reject'} | #passive{type::'fifo'} | #producer{f::fun() | {atom(),atom(),[any()]}},group::atom(),regulators::[#group_rate{} | #counter{} | #rr{} | #cr{}],max_time::'undefined' | integer(),max_size::'undefined' | integer(),latest_dispatch::integer(),check_interval::'undefined' | integer() | {atom(),atom(),byte()},oldest_job::integer(),check_counter::integer(),waiters::[{pid(),reference()}]}
jobs_server.erl:1376: The pattern 'infinity' can never match the type 'undefined' | integer() | {atom(),atom(),byte()}
jsx_parser.erl:64: The pattern <[], Handler, _Opts> can never match the type <'end_array' | 'end_json' | 'end_object' | 'start_array' | 'start_object' | {'float',float()} | {'integer',integer()} | {'key',binary() | {'error',binary(),binary() | [any()]} | {'incomplete',binary(),binary()}} | {'literal','false' | 'null' | 'true'} | {'string',binary() | {'error',binary(),binary() | [any()]} | {'incomplete',binary(),binary()}},{atom() | tuple(),_},#opts{replaced_bad_utf8::boolean(),escaped_forward_slashes::boolean(),single_quoted_strings::boolean(),unescaped_jsonp::boolean(),comments::boolean(),escaped_strings::boolean(),dirty_strings::boolean(),ignored_bad_escapes::boolean(),explicit_end::boolean(),pre_encode::'false' | fun((_) -> any())}>
jsx_parser.erl:65: The pattern <[Event | Rest], Handler, Opts> can never match the type <'end_array' | 'end_json' | 'end_object' | 'start_array' | 'start_object' | {'float',float()} | {'integer',integer()} | {'key',binary() | {'error',binary(),binary() | [any()]} | {'incomplete',binary(),binary()}} | {'literal','false' | 'null' | 'true'} | {'string',binary() | {'error',binary(),binary() | [any()]} | {'incomplete',binary(),binary()}},{atom() | tuple(),_},#opts{replaced_bad_utf8::boolean(),escaped_forward_slashes::boolean(),single_quoted_strings::boolean(),unescaped_jsonp::boolean(),comments::boolean(),escaped_strings::boolean(),dirty_strings::boolean(),ignored_bad_escapes::boolean(),explicit_end::boolean(),pre_encode::'false' | fun((_) -> any())}>
meck.erl:653: The pattern <Mod, Func, Args, [Meck = {'meck', 'exec', _Arity} | Stack]> can never match the type <atom(),_,_,[{atom(),atom(),[any()] | byte(),[any()]},...]>
meck_cover.erl:30: Call to missing or unexported function cover:compile_beam/2
meck_cover.erl:98: Call to missing or unexported function cover:get_term/1
meck_cover.erl:109: Call to missing or unexported function cover:write/2
pokemon_pb.erl:46: The variable _ can never match since previous clauses completely covered the type #pikachu{}
pokemon_pb.erl:52: The pattern <Default, _> can never match since previous clauses completely covered the type <_,'none'>
pokemon_pb.erl:53: The pattern <Val, _> can never match since previous clauses completely covered the type <_,'none'>
protobuffs_compile.erl:675: Function find_extended_msg/2 will never be called
protobuffs_compile.erl:678: Function will never be called
protobuffs_compile.erl:682: Function will never be called
protobuffs_compile.erl:690: Function find_defined_extensions/2 will never be called
protobuffs_compile.erl:693: Function will never be called
protobuffs_compile.erl:697: Function will never be called
riak_kv_pb.erl:52: The pattern <Default, _> can never match since previous clauses completely covered the type <_,'none'>
riak_kv_pb.erl:53: The pattern <Val, _> can never match since previous clauses completely covered the type <_,'none'>
riak_kv_pb.erl:59: The pattern <_, 'repeated_packed', 'undefined', _, _> can never match the type <1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11,'optional' | 'repeated' | 'required',_,'bool' | 'bytes' | 'rpbbucketprops' | 'rpbcontent' | 'rpbindexreq_indexquerytype' | 'rpblink' | 'rpbpair' | 'uint32',[binary() | [binary() | [any()]]]>
riak_kv_pb.erl:60: The pattern <_, 'repeated_packed', [], _, _> can never match the type <1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11,'optional' | 'repeated' | 'required',_,'bool' | 'bytes' | 'rpbbucketprops' | 'rpbcontent' | 'rpbindexreq_indexquerytype' | 'rpblink' | 'rpbpair' | 'uint32',[binary() | [binary() | [any()]]]>
riak_kv_pb.erl:71: The pattern <FNum, 'repeated_packed', Data, Type, _> can never match the type <1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11,'optional' | 'repeated' | 'required',_,'bool' | 'bytes' | 'rpbbucketprops' | 'rpbcontent' | 'rpbindexreq_indexquerytype' | 'rpblink' | 'rpbpair' | 'uint32',[binary() | [binary() | [any()]]]>
riak_kv_pb.erl:151: The pattern <Binary, 'string'> can never match the type <'-infinity' | 'false' | 'infinity' | 'nan' | 'true' | binary() | [integer()] | number(),'bool' | 'bytes' | 'rpbbucketprops' | 'rpbcontent' | 'rpbindexreq_indexquerytype' | 'rpblink' | 'rpbpair' | 'uint32'>
riak_kv_pb.erl:171: The pattern <Types, [{Fnum, Bytes} | Tail], Acc> can never match the type <_,[],[{_,_}]>
riak_pb.erl:52: The pattern <Default, _> can never match since previous clauses completely covered the type <_,'none'>
riak_pb.erl:53: The pattern <Val, _> can never match since previous clauses completely covered the type <_,'none'>
riak_pb.erl:57: The pattern <_, 'repeated', 'undefined', _, _> can never match the type <1 | 2,'optional' | 'required',_,'bytes' | 'uint32',[]>
riak_pb.erl:59: The pattern <_, 'repeated_packed', 'undefined', _, _> can never match the type <1 | 2,'optional' | 'required',_,'bytes' | 'uint32',[]>
riak_pb.erl:60: The pattern <_, 'repeated_packed', [], _, _> can never match the type <1 | 2,'optional' | 'required',_,'bytes' | 'uint32',[]>
riak_pb.erl:65: The pattern <_, 'repeated', [], _, Acc> can never match the type <1 | 2,'optional' | 'required',_,'bytes' | 'uint32',[]>
riak_pb.erl:68: The pattern <FNum, 'repeated', [Head | Tail], Type, Acc> can never match the type <1 | 2,'optional' | 'required',_,'bytes' | 'uint32',[]>
riak_pb.erl:71: The pattern <FNum, 'repeated_packed', Data, Type, _> can never match the type <1 | 2,'optional' | 'required',_,'bytes' | 'uint32',[]>
riak_pb.erl:86: The call riak_pb:enum_to_int(Type::'bytes' | 'uint32',Data::atom()) will never return since it differs in the 1st argument from the success typing arguments: ('pikachu','value')
riak_pb.erl:88: The pattern <'pikachu', 'value'> can never match the type <'bytes' | 'uint32',atom()>
riak_pb.erl:111: The pattern 'true' can never match the type 'false'
riak_pb.erl:117: The pattern 'true' can never match the type 'false'
riak_pb.erl:126: The pattern 'true' can never match the type 'false'
riak_pb.erl:138: The pattern {'value', {_, _, Dict}} can never match the type 'false'
riak_pb.erl:151: The pattern <Binary, 'string'> can never match the type <'-infinity' | 'false' | 'infinity' | 'nan' | 'true' | binary() | [integer()] | number(),'bytes' | 'uint32'>
riak_pb.erl:171: The pattern <Types, [{Fnum, Bytes} | Tail], Acc> can never match the type <_,[],[{_,_}]>
riak_search_pb.erl:52: The pattern <Default, _> can never match since previous clauses completely covered the type <_,'none'>
riak_search_pb.erl:53: The pattern <Val, _> can never match since previous clauses completely covered the type <_,'none'>
riak_search_pb.erl:59: The pattern <_, 'repeated_packed', 'undefined', _, _> can never match the type <1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10,'optional' | 'repeated' | 'required',_,'bytes' | 'float' | 'rpbpair' | 'rpbsearchdoc' | 'uint32',[binary() | [binary() | [any()]]]>
riak_search_pb.erl:60: The pattern <_, 'repeated_packed', [], _, _> can never match the type <1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10,'optional' | 'repeated' | 'required',_,'bytes' | 'float' | 'rpbpair' | 'rpbsearchdoc' | 'uint32',[binary() | [binary() | [any()]]]>
riak_search_pb.erl:71: The pattern <FNum, 'repeated_packed', Data, Type, _> can never match the type <1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10,'optional' | 'repeated' | 'required',_,'bytes' | 'float' | 'rpbpair' | 'rpbsearchdoc' | 'uint32',[binary() | [binary() | [any()]]]>
riak_search_pb.erl:86: The call riak_search_pb:enum_to_int(Type::'bytes' | 'float' | 'rpbpair' | 'rpbsearchdoc' | 'uint32',Data::atom()) will never return since it differs in the 1st argument from the success typing arguments: ('pikachu','value')
riak_search_pb.erl:88: The pattern <'pikachu', 'value'> can never match the type <'bytes' | 'float' | 'rpbpair' | 'rpbsearchdoc' | 'uint32',atom()>
riak_search_pb.erl:151: The pattern <Binary, 'string'> can never match the type <'-infinity' | 'false' | 'infinity' | 'nan' | 'true' | binary() | [integer()] | number(),'bytes' | 'float' | 'rpbpair' | 'rpbsearchdoc' | 'uint32'>
riak_search_pb.erl:171: The pattern <Types, [{Fnum, Bytes} | Tail], Acc> can never match the type <_,[],[{_,_}]>
sfmt_pure.erl:458: The pattern [H | T] can never match the type []
sfmt_pure.erl:463: The pattern [H | T] can never match the type []
